# 14. 그래프(Graph)
- 정점 `vertex` : 연결의 대상이 되는 개체 또는 위치
- 간선 `edge` : 정점 사이의 연결  

#### 그래프의 종류
> - 방향 그래프 / 무방향 그래프 : 간선에 방향정보가 유/무에 따른 분류
> - 완전 그래프 : 각각의 정점에서 다른 모든 정점을 연결한 그래프
> - 가중치 그래프 : 간선에 가중치 정보가 있음
> - 부분 그래프 : 원 그래프의 일부 정점 및 간선으로 이루어진 그래프

#### 그래프의 집합 표현
<p align=center><img src="https://user-images.githubusercontent.com/31379392/148682344-c2be8263-5276-42dd-8a00-f85a17c2505f.jpg" width = "500"><br>윤성우 저, 열혈 자료 구조</p>

```
// 무방향 그래프의 정접의 집합(V)과 간선(E)의 집합
V(G1) = {A, B, C, D}          E(G1) = {(A, B), (A, C), (A, D), (B, C), (C, D)}

// 방향 그래프의 정접의 집합(V)과 간선(E)의 집합
V(G3) = {A, B, C, D}          E(G3) = {<A, B>, <A, C>, <D, A>}
```
💡 무방향 그래프와 방향 그래프의 유일한 집합 표현의 차이는 방향성이 있는 **간선의 표시법**에 있음  

#### 구현 방법 : 행렬 vs 리스트
- 인접 행렬(adjacent matrix) 기반 그래프 ➡️ **2차원 배열** 활용 (가로세로의 길이가 같은)
- 인접 리스트(adjacent list) 기반 그래프 ➡️ **연렬 리스트** 활용

<p align=center><img src="https://user-images.githubusercontent.com/31379392/148682793-47b1433f-9265-4bad-b343-c010931fe4ee.jpg" width = "500"><br>윤성우 저, 열혈 자료 구조</p>

> **인접 행렬 표현**  
> - 간선으로 연결되면 1  
> - 방향 그래프는 무방향 그래프와 다르게 대칭이 아님

<p align=center><img src="https://user-images.githubusercontent.com/31379392/148682795-99553183-bd20-45be-a3ee-a5dd9854bfbe.jpg" width = "500"><br>윤성우 저, 열혈 자료 구조</p>

> **인접 리스트 표현**  
> - 방향 그래프와 무방향 그래프의 차이점 ➡️ 연결 리스트에 추가하는 정점의 수

---

## 14 - 1. 그래프의 탐색
### 👩‍🏫 DFS : 깊이 우선 탐색 (Depth First Search)
여러 갈래의 길 중 **한 길**을 깊이 파고드는 것  

**how to**
> 1. 간선으로 연결된 정점 중 하나의 정점만 선택
> 2. 1을 반복하다가 선택할 정점(아직 탐색을 하지 않은)이 없으면 이전 단계의 정점으로 감
> 3. 시작점에 다시 도착하면 탐색 종료

#### 구현
- 스택 : **경로 정보의 추적**을 목적
- 배열 : **방문 정보의 기록**을 목적

DFS에서는 갔던 길을 되돌아 오는 상황이 존재. (더이상 방문할 정점이 없을 때)  
➡️ 스택을 사용해 경로를 기록하고, 되돌아 올 때 사용한다.  

**how to**  
> 1. 방문한 정점을 스택에 **push**  
> 2. 방문할 정점이 없으면 스택을 **pop** ➡️ 경로 확인 후 되돌아 옴  
> 3. 시작점에 도달할 때까지 1, 2를 반복

### 👩‍🏫 BFS : 너비 우선 탐색 (Breadth First Search)
연결된 **모든 길**을 다 가는 것  

**how to**
> 1. 간선으로 연결된 모든 정점을 선택
> 2. 1을 반복하다가 더이상 탐색할 정점이 없으면 탐색 종료

💡 BFS에서 모든 정점은 다음 정점을 선택할 기회를 가진다. 다만, 연결된 정점이 모두 탐색 왼료된 상태라면 해당 정점은 선택 기회만 있었을 뿐, 다음 정점을 선택하지는 않는다.

#### 구현
- 큐 : **방문 차례의 기록**을 목적
- 배열 : **방문 정보의 기록**을 목적

**how to**  
> 1. 방문한 정점을 큐에 **enqueue**  
> 2. 큐에서 정점을 하나 꺼내고(**dequeue**), 해당 정점과 연결된 모든 노드에 방문(**enqueue**)  
> 3. 큐에 들어있는 정점이 없을 때까지 1, 2 반복  

💡 BFS에 있어서 큐는 방문할 정점의 순서를 기록하기 위한 것

## 14 - 2. 최소 비용 신장 트리
