# 09. 우선순위 큐와 힙

## 우선순위 큐와 힙

### 우선순위 큐 (Priority Queue)

- 우선순위 큐에 넣은 순서와 관계없이, 우선순위가 높은 데이터가 먼저 나온다.
- `enqueue`는 우선순위 큐에 데이터를 넣는 것으로 큐와 같지만, `dequeue`는 데이터를 꺼낸다는 사실 외에 **우선순위가 높은** 데이터 부터 꺼낸다는 점에서 차이가 있다.

### 힙 (Heap)

- 이진트리 (`완전 이진 트리`)
- `루트 노드`에 저장된 값이 **가장 커야** 한다.
    - 값 : 우선순위 큐에서는, 우선순위.
    - 최대 힙(`max heap`) : 루트노드로 올라갈수록 저장된 값이 `커지는` 완전 이진트리
    - 최소 힙(`min heap`) : 루트노드로 올라갈수록 저장된 값이 `작아지는` 완전 이진 트리

- **우선순위 큐를 구현**하는 데에 사용  

> 1. `배열`은 삽입 / 삭제 연산이 오래걸리고, 우선순위 비교에 어려움이 있다. 
>2. `연결 리스트`의 경우에도, 우선순위 비교에 처음부터 마지막까지 비교해야한다는 단점이 있다.

## 힙의 구현

### 힙에서의 데이터 저장 과정

🔍 최소 힙을 기준으로, 데이터의 저장과정을 살펴보자!

힙에서 값을 `우선순위`로 생각하면, 자식노드 데이터의 우선순위 <= 부모노드의 우선순위이므로, 우선순위를 힙으로 표현할 수 있다.

1. 새로운 데이터는 우선순위가 제일 낮다고 가정하고, `마지막 위치`에 저장한다.
    - `마지막 위치` : 현재 이진트리 마지막 레벨의 가장 오른쪽 위치
2. 저장한 노드와 부모노드의 우선순위를 비교해서 위치를 바꾸거나, 유지한다.
3. 바꾼 후에도 그 바꾼 위치에서 부모노드와 비교를 계속하여 올바른 위치를 찾는다.

### 힙에서의 데이터 삭제 과정

🤔 우선순위가 높은 것을 먼저 삭제하기 위해(`우선순위 큐`를 구현하기 위해) 힙을 구현하고 있다!

✔ **루트 노드** (가장 우선순위가 높은 노드)를 삭제하고, 그 빈 공간을 어떻게 채워야 할까?

1. `마지막 위치`의 노드를 `루트 노드`로 옮긴 후 자식노드와 비교한다. 
    - `마지막 위치` : 현재 이진트리 마지막 레벨의 가장 오른쪽 위치
2. 자식 노드의 우선순위가 현재 루트 노드보다 높다면, 자식 노드와 위치를 바꾼다.

### 힙 기반 데이터 저장 / 삭제의 시간 복잡도

- 삽입, 삭제시의 비교 연산은 부모 노드와 자식 노드에서만 일어난다
- 트리 높이 수 만큼만 비교연산을 진행 👉 트리의 높이가 하나 늘어날 때마다 비교 연산의 횟수가 하나 증가


- 힙에서 트리의 높이가 하나 늘 때마다 저장할 수 있는 데이터의 수는 두 배씩 증가 👉 데이터의 수가 두 배 증가할 때마다 비교 연산의 횟수는 1회 증가

> 힙 기반 데이터 저장 / 삭제의 시간 복잡도는 `O(log₂n)`

### 힙의 구현 : 배열 기반

연결리스트를 기반으로 힙을 구현하는 경우 힙의 `마지막 위치`에 새 노드를 추가하는 데 어려움이 있다.

#### 배열 기반 이진 트리

- 인덱스가 0인 위치의 배열 요소는 사용하지 않는다.
- 노드에 고유 번호(각 노드의 데이터가 저장될 `배열의 인덱스`)를 부여한다.

- 자식노드와 부모 노드의 인덱스 값 찾기
    - `왼쪽 자식 노드`의 인덱스 값 : 부모 노드의 인덱스 값 * 2
    - `오른쪽 자식 노드`의 인덱스 값 : 누모 노드의 인덱스 값 * 2 + 1
    - `부모 노드`의 인덱스 값 : 자식 노드의 인덱스 값 / 2 (*정수형*)

#### 힙의 구현 :  데이터 삭제

> 힙의 마지막 노드를 루트노드 위치로 올린 후 자식 노드와의 비교과정을 거쳐 , 최종적으로 자신의 위치를 찾을 때까지 내린다.

1. `함수`(교재에서는 GetHiPriChildIDX)로 노드의 인덱스 값을 전달하여 노드의 두 자식 노드 중 우선순위가 높은 것을 반환받는다.
    - 자식 노드가 존재하지 않는다면 0, 자식노드가 하나라면 그 노드의 인덱스 값을 반환
2. 삭제할 데이터를 return하기 위해 미리 저장해 두고,
3. 힙의 마지막 노드를 저장한 후
4. 루트 노드가 위치해야 할 인덱스 값(1)과 자식노드 중 우선순위가 높은 것을 비교하는 것을 반복하여 최종 위치를 결정한다.
5. 완료시 삭제한 데이터를 return하면서 종료

#### 힙의 구현 : 데이터 삽입

> 새로운 데이터를 마지막 위치에 저장한 후, 최종적으로 자신의 위치를 찾을 때까지우선순위를 비교하여 위로 올린다.

1. 새 노드가 저장될 인덱스 값을 저장(`마지막 위치`)
2. 새노드의 생성과 초기화
3. 새 노드가 저장될 위치를 찾을 때까지 새 노드와 부모노드의 우선순위를 비교한다.
4. 최종 위치를 찾으면 새 노드를 배열에 저장하고, 배열의 길이에 1을 더한다.

#### 우선순위의 판단 기준을 힙에 설정

힙에 저장할 데이터와 우선순위를 구조체 heapElem(HData, Priority를 포함한다)과 같은 형태로 따로 선언하지 않고, 구조체 Heap을 아래와 같이 선언한다. 

```c
typedef struct _heap
{
    PriorityComp * comp;
    int numOfData;
    HData heapArr[HEAP_LEN];
} Heap;
```
`PriorityComp * comp`는 두 개의 데이터를 대상으로 우선순위의 높고 낮음을 판단하는 함수를 등록하기 위한 포인터 변수이다.

```c
typedef int PriorityComp * comp(HData d1, Hdata d2); 
```

프로그래머가 직접 여기에 등록할 함수를 정의할 수 있고, 다음과 같은 가이드라인을 제시할 수 있다.

- `첫번째 인자`가 우선순위가 높은 경우, **0보다 큰 값**이 반환
- `두번째 인자`가 우선순위가 높은 경우, **0보다 작은 값**이 반환
- `우선순위가 동일`한 경우, **0**이 반환

이와 같은 경우, 기준이 되는 함수만 정의해서 등록하면 된다.

## 우선순위 큐의 구현

구현한 힙을 기반으로 우선순위 큐를 구현

- 구현한 힙의 삽입, 삭제 함수는 우선순위 큐의 `enqueue`, `dequeue`와 같다.
- 구현한 힙의 헤더에서 구조체 `Heap`,  typedef로 선언된 `HData`를 이용

PriorityQueue.h
```c
#ifndef __PRIORITY_QUEUE_H__
#define __PRIORITY_QUEUE_H__

#include "Heap.h"   // 완성된 힙 헤더

typedef Heap PQueue;
typedef HData PQData;

void PQueueInit(PQueue * ppq, PriorityComp pc); // 초기화
int PQIsEmpty(PQueue * ppq);

void PEnqueue(PQueue * ppq, PQData data); // 저장
PQData PDequeue(PQueue *ppq); // 삭제

#endif
```