# 04. LinkedList

## 04 - 1. LinkedListμ κ°λ…μ μΈ μ΄ν•΄

**ν•„μ”ν•  λ•λ§λ‹¤ Nodeλ¥Ό μƒμ„±ν•΄μ„ dataλ¥Ό μ €μ¥ν•κ³  λ°°μ—΄μ²λΌ μ—°κ²°(next) => `λ™μ  ν• λ‹Ή λ°°μ—΄`**

### π‘©β€π« Node
LinkedListμ—μ„ μ‚¬μ©λλ” λ³€μ ν•νƒ (κµ¬μ΅°μ²΄)
```
typedef struct _node
{
  int data;             // data κ³µκ°„
  struct _node * next;  // λ‹¤μ λ³€μμ μ£Όμ†
} Node;
```

- `head` : listμ μ‹μ‘ nodeλ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„° λ³€μ
- `tail` : listμ λ§μ§€λ§‰ nodeλ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„° λ³€μ
- `node` : λ‹¤μ nodeλ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„° λ³€μ
- `cur` : data searchμ— μ‚¬μ©λλ” ν¬μΈν„° λ³€μ  
( μ΄κΈ° μƒνƒμ—μ„λ” λ¨λ‘ `NULL`μ„ κ°€λ¦¬ν‚΄ )

### π‘©β€π« Data Insert
`newNode`κ°€ listμ λ§μ§€λ§‰μ— λ“¤μ–΄κ°€λ” μƒν™©
1. λ…Έλ“ μƒμ„± λ° μ΄κΈ°ν™” `newNode`
2. if μ²«λ²μ§Έ λ…Έλ“, `head` -> `newNode`
3. κΈ°μ΅΄ λ§μ§€λ§‰ λ…Έλ“μ `next` -> `newNode`
4. `tail` -> `newNode`

```
while(1)
{
  // 1-1. λ…Έλ“ μƒμ„±(λ©”λ¨λ¦¬ λ™μ  ν• λ‹Ή)
  newNode = (Node*)malloc(sizeof(Node));
  // 1-2. μ΄κΈ°ν™” (λ°μ΄ν„° μ €μ¥ / next -> NULL)
  newNode->data = realData;
  newNode->next = NULL:

  // 2. μ²«λ²μ§Έ λ…Έλ“λΌλ©΄ head -> μƒλ΅ μƒμ„±ν• λ…Έλ“
  if(head == NULL)  // μ΄μ „μ— μƒμ„±λ λ…Έλ“κ°€ μ—†μ—λ‹¤λ©΄ head -> NULLμΈ μƒνƒ
    head = newNode;

  // 3. λ§μ§€λ§‰ λ…Έλ“μ next -> μƒλ΅ μƒμ„±ν• λ…Έλ“
  //    (λ§μ§€λ§‰ λ…Έλ“λ” tailμ΄ κ°€λ¦¬ν‚¤κ³  μλ” μƒνƒ)
  else
    tail->next = newNode;

  // 4. tail->λ§μ§€λ§‰ λ…Έλ“(μƒλ΅ μƒμ„±ν• λ…Έλ“)
  tail = newNode;
}
```
### π‘©β€π« Data Search
**`cur = cur->next;`**

`cur`μ΄ listμ `head`λ¶€ν„° `tail`κΉμ§€ μμ°¨μ μΌλ΅ λ¨λ“  λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ©΄μ„ Search

```
if(head != NULL)
{
  // 1. headλ¶€ν„° μ‹μ‘
  cur = head;

  while(cur->next != NULL)    // λ‹¤μ λ…Έλ“κ°€ μ΅΄μ¬ν•λ©΄
  {
    // 2. λ‹¤μ λ…Έλ“ μ΅°ν
    cur = cur->next;
  }
}
```
### π‘©β€π« Data Delete
list μ „μ²΄λ¥Ό μ‚­μ ν•λ” μƒν™© (`head`λ¶€ν„° `tail`κΉμ§€ μμ°¨μ μΌλ΅ μ‚­μ )

1. deleteμ— μ‚¬μ©ν•  ν¬μΈν„° λ³€μ μ„ μ–Έ  
    `delNode` : μ‚­μ ν•  λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„° λ³€μ  
    `delNextNode` : μ‚­μ ν•  λ…Έλ“μ λ‹¤μ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„° λ³€μ  
2. `delNode`λ” `head`λ¶€ν„° `tail`κΉμ§€ μμ°¨μ μΌλ΅ μ‚­μ  (`free`)  
  `delNextNode`λ” λ‹¤μμ— μ‚­μ ν•  λ…Έλ“λ¥Ό κ°€λ¦¬ν‚΄

```
if(head == NULL)   // μ‚­μ ν•  list μ—†μ
  return 0;
else
{
  // 1. ν¬μΈν„° λ³€μ μ„ μ–Έ
  Node * delNode = head;            // listμ μ‹μ‘λ¶€ν„°
  Node * delNextNode = head->next;  // delNodeμ λ‹¤μλ¶€ν„°

  // 2. μ‚­μ 
  free(delNode);                    // mallocμΌλ΅ ν• λ‹Ήν• λ™μ  λ©”λ¨λ¦¬ κ³µκ°„μ΄λ―€λ΅ free μ‚¬μ©ν•΄μ„ λ©”λ¨λ¦¬ ν•΄μ 

  // 3. λ‹¤μ λ…Έλ“κ°€ μ΅΄μ¬ν•λ‹¤λ©΄ listκ°€ λλ‚ λ•κΉμ§€ μμ°¨μ μΌλ΅ μ‚­μ 
  while(delNextNode != NULL)
  {
    delNode = delNextNode;            // μ‚­μ ν•  λ…Έλ“
    delNextNode = delNextNode->next;  // κ·Έ λ‹¤μ λ…Έλ“
    free(delNode);
  }
}
```

- **`delNextNode`μ μ΅΄μ¬ μ΄μ **
> `delNode`κ°€ κ°€λ¦¬ν‚¤κ³  μλ” λ…Έλ“λ¥Ό μ‚­μ ν•κ³  λ‚λ©΄ listμ—μ„ κ·Έ λ‹¤μ λ…Έλ“λ¥Ό μμ°¨μ μΌλ΅ μ‚­μ ν•΄μ•Ό ν•λ”λ°,  
> ν•΄λ‹Ή λ…Έλ“κ°€ μ‚­μ λλ©΄ `next` ν¬μΈν„°λ„ μ‚¬λΌμ§€λ―€λ΅ κ·Έ λ‹¤μ λ…Έλ“λ¥Ό μ°Ύμ„ μ μ—†λ‹¤.  
> λ”°λΌμ„ `delNextNode`κ°€ λ‹¤μ λ…Έλ“λ¥Ό κ°€λ¦¬μΌμ„ listμ λκΉμ§€ `delete`λ¥Ό μν–‰ν•  μ μλ„λ΅ ν•λ‹¤.


dataλ¥Ό insert / search / delete ν•  λ•, ν•΄λ‹Ή λ…Έλ“κ°€ μ²«λ²μ§Έ λ…Έλ“μ΄λƒ μ•„λ‹λƒμ— λ”°λΌ λ°©λ²•μ— μ°¨μ΄κ°€ μμ—μμ„ κΈ°μ–µν•΄λΌ!

## 04 - 2. ADT
### Singly Linked List
μ—°κ²° ν•νƒκ°€ **ν•μ½ λ°©ν–¥**μΌλ΅ μ „κ°λκ³  **μ‹μ‘κ³Ό λ**μ΄ λ¶„λ…ν μ΅΄μ¬ν•λ” **Linked List**

### μ •λ ¬ κΈ°λ¥μ΄ μ¶”κ°€λ list μλ£κµ¬μ΅°μ ADT (Ch.03)
```
// LinkedListμ μ •λ ¬ κΈ°μ¤€μ„ μ§€μ •ν•κΈ° μ„ν• ν•¨μ
void setSortRule(List *plist, int (*comp)(Ldata d1, LData d2));
```
### μƒ λ…Έλ“λ¥Ό μ¶”κ°€ν•  λ• head vs tail
**head**  
`μ¥μ ` ν¬μΈν„° λ³€μ tailμ΄ λ¶ν•„μ”  
`λ‹¨μ ` μ €μ¥λ μμ„λ¥Ό μ μ§€ν•μ§€ μ•μ(μ•μ—μ„λ¶€ν„° ν•λ‚μ”© λ‹¤ λ°€λ¦Ό)  

**tail**  
`μ¥μ ` μ €μ¥λ μμ„κ°€ μ μ§€λ¨  
`λ‹¨μ ` ν¬μΈν„° λ³€μ tailμ΄ ν•„μ”   

### π‘©β€π« Dummy Node κΈ°λ°μ Singly Linked List
*insert / search / delete μ‹, ν•΄λ‹Ή λ…Έλ“κ°€ μ²«λ²μ§Έλƒ μ•„λ‹λƒμ— λ”°λΌ λ°©λ²•μ΄ λ‹¬λΌμ§€λ” λ‹¨μ μ„ κ·Ήλ³µν•κ³ μ ν•¨*
#### how to
> - λ…Έλ“λ¥Ό `head`μ—μ„λ¶€ν„° μ±„μ›λ„£μ => `tail`μ΄ μ—†μ–΄μ§
> - list λ§¨ μ•μ— `Dummy node` μ΅΄μ¬

**`Dummy node`: μ ν¨ν• dataλ¥Ό μ§€λ‹μ§€ μ•λ” λΉ λ…Έλ“**  
λΉ λ…Έλ“λ¥Ό list λ§¨ μ•μ— λ„£μ–΄λ‘λ©΄ κµ¬μ΅°μƒ μ ν¨ν• λ…Έλ“λ“¤μ΄ λ‘λ²μ§Έλ¶€ν„° μ‹μ‘λλ―€λ΅, insert / search / delete κ³Όμ •μ„ μΌκ΄€λ ν•νƒλ΅ κµ¬μ„± κ°€λ¥.

#### Linked List κµ¬μ΅°μ²΄
```
typedef struct _linkedList
{
  Node * head;                      // dummy nodeλ¥Ό κ°€λ¦¬ν‚΄
  Node * cur;                       // μ°Έμ΅° λ° μ‚­μ λ¥Ό λ„μ›€
  Node * before;                    // μ‚­μ λ¥Ό λ„μ›€
  int numOfData;                    // μ €μ¥λ λ°μ΄ν„°μ μλ¥Ό κΈ°λ΅
  int (*comp)(LData d1, LData d2);  // μ •λ ¬μ κΈ°μ¤€μ„ λ“±λ΅
} LinkedList;
```
**κµ¬μ΅°μ²΄λ¥Ό μ‚¬μ©ν•΄μ•Ό ν•λ” μ΄μ **  
κµ¬μ΅°μ²΄λ¥Ό μ‚¬μ©ν•μ§€ μ•λ”λ‹¤λ©΄ listλ§λ‹¤ head, cur ν¬μΈν„° λ³€μλ¥Ό λ³„λ„λ΅ μ„ μ–Έν•΄μ¤μ•Όν•¨.  
λ§μ•½ λ‹¤μμ listκ°€ ν•„μ”ν• μƒν™©μ΄λΌλ©΄ λ§¤λ² ν•„μ”ν• ν¬μΈν„° λ³€μλ¥Ό μ„ μ–Έν•΄μ•Όν•λ―€λ΅ λ¶νΈν•λ‹¤.

#### π‘©β€π« Initialize

`head`μ™€ `head`κ°€ κ°€λ¦¬ν‚¤λ” `dummynode`κΉμ§€ μƒμ„±λ μƒνƒ
```
void ListInit(List * plist)
{
  plist->head = (Node*)malloc(sizeof(Node));  // dummy node μƒμ„±
  plist->head->next = NULL;
  plist->comp = NULL;                         // NULLλ΅ μ΄κΈ°ν™”
  plist->numOfData = 0;                       // 0μΌλ΅ μ΄κΈ°ν™”
}
```
#### π‘©β€π« Insert  
μ •λ ¬κΈ°μ¤€(`comp`)μ΄
- μ—†λ‹¤λ©΄ => `head`μ— λ…Έλ“ μ¶”κ°€ => `FInsert`
- μλ‹¤λ©΄ => μ •λ ¬κΈ°μ¤€μ— λ§μ¶°μ„ λ…Έλ“ μ¶”κ°€ => `SInsert`

**FInsert ν•¨μ**  
*listμ λ§¨ μ•μ— λ…Έλ“λ¥Ό μ¶”κ°€ν•λ” ν•¨μ (`dummynode` μ μ™Έ)*
##### how to
>1. insertν•  `newNode` μƒμ„±
>2. `newNode`μ— data μ €μ¥
>3. `newNode`κ°€ listμ μ²«λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤κ² ν•¨(`dummy node` μ μ™Έ)
>4. `dummy node`κ°€ `newNode`λ¥Ό κ°€λ¦¬ν‚¤κ² ν•¨
>5. listμ λ…Έλ“ κ°―μ μ¦κ°€μ‹ν‚΄
```
void FInsert(List * plist, LData data)
{
  // 1. μƒμ„± 2. λ°μ΄ν„° μ €μ¥
  Node * newNode = (Node*)malloc(sizeof(Node));
  newNode->data = data;

  // 3. ν¬μΈν„° μ •λ¦¬
  newNode->next = plist->head->next;
  plist->head->next = newNode;

  // 4. λ…Έλ“ κ°―μ μ¦κ°€
  (plist->numOfData)++;
}
```

#### π‘©β€π« Search
`cur` : ν„μ¬ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„° λ³€μ  
`before` : `cur`λ³΄λ‹¤ ν•λ‚ μ΄μ „μ λ…Έλ“λ¥Ό κΈ°λ¦¬ν‚¤λ” ν¬μΈν„° λ³€μ (deleteμ‹μ— ν•„μ”ν•¨)  

**LFirst ν•¨μ**  
*`cur`μ΄ listμ μ²«λ²μ§Έ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤κ² ν•λ” ν•¨μ (`dummy node` μ μ™Έ)*  
```
plist->before = plist->head;    // before : dummy node κ°€λ¦¬ν‚΄
plist->cur = plist->head->next; // cur : μ ν¨ν• μ²«λ²μ§Έ λ…Έλ“ κ°€λ¦¬ν‚΄
```
**LNext ν•¨μ**  
*`cur`μ΄ λ‹¤μ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤κ² ν•λ” ν•¨μ*  
```
plist->before = plist->cur;     // before : curκ°€ κ°€λ¦¬ν‚¤λ κ²ƒμ„ κ°€λ¦¬ν‚΄
plist->cur = plist->cur->next;  // cur : λ‹¤μ λ…Έλ“ κ°€λ¦¬ν‚΄
```

#### π‘©β€π« Delete
**LRemove ν•¨μ**  
*`cur`μ΄ κ°€λ¦¬ν‚¤κ³  μλ” λ°μ΄ν„°λ¥Ό μ‚­μ ν•λ” ν•¨μ*   

`rpos` : μ†λ©Έλ€μƒμ μ£Όμ†(`cur`μ΄ κ°€λ¦¬ν‚¤κ³  μλ” λ…Έλ“μ μ£Όμ†)  
`rdata` : μ†λ©Έλ€μƒμ λ°μ΄ν„°(`cur`μ΄ κ°€λ¦¬ν‚¤κ³  μλ” λ…Έλ“μ λ°μ΄ν„°)  

**how to**  
>1. μ†λ©Έλ€μƒμΈ λ…Έλ“λ¥Ό `rpos`μ— μ €μ¥  
>2. `cur`μ΄ κ°€λ¦¬ν‚¤κ³  μλ” λ…Έλ“λ¥Ό λ¦¬μ¤νΈμ—μ„ μ κ±° (μ—°κ²°λ ν¬μΈν„°λ¥Ό λλ” λ°©μ‹)  
>3. `cur`μ μ„μΉλ¥Ό μ κ±°λ λ…Έλ“ μ΄μ „ μ„μΉλ΅ μ¬μ΅°μ • (`before` μ‚¬μ©!)  
>4. `rpos` λ…Έλ“ μ†λ©Έ(`free`), λ…Έλ“ μ κ°μ†(`numOfData`)  

## 04 - 3. Sort Insert
1. μ •λ ¬ κΈ°μ¤€μ„ `comp`μ— λ“±λ΅ (`setSortRule` ν•¨μ νΈμ¶)  
2. `SInsert` ν•¨μμ—μ„ `comp`μ— λ“±λ΅λ μ •λ ¬κΈ°μ¤€λ€λ΅ `data`λ¥Ό μ •λ ¬ν•μ—¬ μ €μ¥  

### π‘©β€π« SInsert
**how to**  
1. μƒ λ…Έλ“ μƒμ„± ν›„ λ°μ΄ν„° μ €μ¥  
    - `newNode` : μƒμ„±λ μƒ λ…Έλ“  
    - `pred` : μƒ λ…Έλ“κ°€ λ“¤μ–΄κ° μ„μΉμ μ΄μ „ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚΄  
2. `comp`μ— μ €μ¥λ μ •λ ¬κΈ°μ¤€μ— λ”°λΌ `newNode`κ°€ λ“¤μ–΄κ° μ„μΉ μ°Ύμ (`pred`λ¥Ό μ΄λ™μ‹ν‚΄)  
3. ν•΄λ‹Ή μ„μΉμ— `newNode` μ‚½μ… (ν¬μΈν„°λ΅ list μ—°κ²°)  
4. listμ λ…Έλ“ μ μ¦κ°€ (`numOfData`)  


*`pred`κ°€ κ°€λ¦¬ν‚¤λ” λ…Έλ“λ¥Ό `dummy node`μ²λΌ μ·¨κΈ‰ν•λ©΄, `SInsert`μ μ‘λ™λ°©μ‹μ€ `newNode`λ¥Ό listμ μ²μμ— μ‚½μ…ν•λ” κ²ƒμ΄λΌκ³  μƒκ°ν•  μ μλ‹¤.*  

#### μ •λ ¬ κΈ°μ¤€μ— λ”°λ¥Έ `newNode` μ‚½μ… μ„μΉ μ°ΎκΈ°
```
//     1. listκ°€ μ•λλ‚¬κ³      2. newNodeκ°€ λ“¤μ–΄κ° μ„μΉλ¥Ό λ»μ°Ύμ•μΌλ©΄
while(pred->next != NULL && plist->comp(data, pred->next->data) != 0)
{
  pred = pred->next;   // μ΄ μ„μΉκ°€ μ•„λ‹λ‹ λ‹¤μ λ…Έλ“λ΅ μ΄λ™
}
```
1. `pred->next != NULL` : `pred`κ°€ λ§μ§€λ§‰ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ”κ² μ•„λ‹μ§€
2. `plist->comp(data, pred->enxt->data) != 0` : `newNode`μ™€ `pred`μ λ‹¤μ λ…Έλ“μ μ°μ„ μμ„ λΉ„κµ  
    - `comp == 0`  
        : **newNode**κ°€ **predμ λ‹¤μ λ…Έλ“**λ³΄λ‹¤ **μ•**μ— μ„μΉν•΄μ•Όν•¨
    - `comp == 1`  
        : **newNode**κ°€ **predμ λ‹¤μ λ…Έλ“**λ³΄λ‹¤ **λ’¤**μ— μ„μΉν•΄μ•Όν•¨
